#!/bin/bash -eu
#
# (c) Copyright 2017-2018 SUSE LLC
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#
# Bootstrap the runtime environment to enable running Ardana development
# environment:
#   * ensure that the bootstrap ansible venv exists and is in PATH
#
# The output of this command it intended to be evaluated by the caller
# to update their environment.
#

set -eu
set -o pipefail

get_distro_family()
{
    if grep -qs ID_LIKE /etc/os-release
    then
        grep ID_LIKE /etc/os-release | \
            cut -d= -f2 | \
            tr -d '"' | \
            tr -d "'" | \
            tr -d '[:space:]'
    elif grep -qs 'ID="sles"' /etc/os-release
    then
        echo suse
    fi
}

is_ubuntu()
{
    [[ ( -x /usr/bin/lsb_release ) && ( "$(lsb_release -is)" == "Ubuntu" ) ]]
}

is_trusty()
{
    [[ ( -x /usr/bin/lsb_release ) && ( "$(lsb_release -cs)" == "trusty" ) ]]
}

version_at_least()
{
    local cur="${1}" tgt="${2}"

    # true if cur >= tgt
    [[ "${cur}" == "$(printf '%s\n' ${cur} ${tgt} | sort -rV | head -n1)" ]]
}

# May need some minimal packages to be able to create an ansible venv
req_pkgs=()

venv_cmd=/usr/bin/virtualenv

# Determine which shell function will be used to install packages
# NOTES:
#   * openSUSE Leap 42 bash includes quotes in distro_family value
#   * debian and suse use different names for Python development package
distro_family=$(get_distro_family)
case "${distro_family}" in
(debian)
    pkg_install="sudo env DEBIAN_FRONTEND=noninteractive apt-get --quiet --yes install"
    if is_trusty
    then
        # On Trusty CI nodes virtualenv is installed under /usr/local/bin
        if [[ -x /usr/local/bin/virtualenv ]]
        then
            venv_cmd=/usr/local/bin/virtualenv
        fi
    fi
    [[ -e /usr/include/python2.7/Python.h ]] || req_pkgs+=( python-dev )
    ;;
(suse)
    pkg_install="sudo zypper install --no-confirm"
    [[ -e /usr/include/python2.7/Python.h ]] || req_pkgs+=( python-devel )
    ;;
(*)
    echo "Unsupported distro family: '${distro_family}'"
    exit 1
    ;;
esac

# Need wget to retrieve files
[[ -x /usr/bin/wget ]] || req_pkgs+=( wget )

# Need gcc to build wheels
[[ -x /usr/bin/gcc ]] || req_pkgs+=( gcc )

# Need virtualenv command
[[ -x ${venv_cmd} ]] || req_pkgs+=( python-virtualenv )

# Need osc to be able to build Cloud8 RPMs
osc_cmd=/usr/bin/osc
if [[ ! -x ${osc_cmd} ]] || ! version_at_least $(${osc_cmd} --version) 0.162
then
    if is_ubuntu
    then
        # Trusty version of osc is way too old, Xenial version is old,
        # so we set up to install latest available (x)Ubuntu version
        # available from OBS repos
        osc_list="/etc/apt/sources.list.d/osc.list"
        osc_repo="http://download.opensuse.org/repositories/openSUSE:/Tools/xUbuntu_$(lsb_release -rs)"
        # If the osc.list repo source hasn't been added, then set it up here
        if [[ ! -e ${osc_list} ]]
        then
            echo "Add OBS Tools repo to system APT repos" 1>&2
            echo "deb ${osc_repo}/ ./" | sudo tee ${osc_list} 1>&2
            wget -q -O - ${osc_repo}/Release.key | sudo apt-key add - 1>&2
            sudo apt-get --quiet --yes update 1>&2
            echo "Removing any existing osc related packages" 1>&2
            sudo apt-get --quiet --yes remove --purge osc obs-build 1>&2
        fi
    fi

    req_pkgs+=( osc )
fi

# Need createrepo to initialise the NEW_RPMS overrides repo
[[ -x /usr/bin/createrepo ]] || req_pkgs+=( createrepo )

# Install required packages if needed
if (( ${#req_pkgs[@]} > 0 ))
then
    ${pkg_install} "${req_pkgs[@]}" 1>&2
fi

#
# Ardana env settings
#

ardana_cache="${HOME}/.cache-ardana"

# We may need to prepend new path elements to PATH
ardana_paths=""


#
# Vagrant runtime env setup
#
vagrant_cache="${ardana_cache}/vagrant"
vagrant_downloads="${vagrant_cache}/downloads"
vagrant_version="${ARDANA_VAGRANT_VERSION:-1.8.7}"
vagrant_arch="${ARDANA_ARCH:-x86_64}"
vagrant_base="${vagrant_cache}/${vagrant_version}"
vagrant_home="${vagrant_base}/home"
vagrant_ld_path="${vagrant_base}/opt/vagrant/embedded/lib"
vagrant_pkg_path="${vagrant_base}/opt/vagrant/embedded/lib/pkgconfig"
vagrant_url_base="https://releases.hashicorp.com/vagrant"

is_vagrant_version()
{
    local tgt_ver="${1}" cur_ver

    if [[ ! -x "/usr/bin/vagrant" ]]
    then
        return 1
    fi

    cur_ver="$(/usr/bin/vagrant --version | cut -d' ' -f 2)"

    [[ "${cur_ver}" == "${tgt_ver}" ]]
}

# if vagrant is not installed, or not the desired version
if ! is_vagrant_version "${vagrant_version}"
then
    mkdir -p "${vagrant_downloads}"

    sha=vagrant_${vagrant_version}_SHA256SUMS
    case "${distro_family}" in
    (debian)
        pkg=vagrant_${vagrant_version}_${vagrant_arch}.deb
        ;;
    (suse)
        pkg=vagrant_${vagrant_version}_${vagrant_arch}.rpm
        ;;
    esac

    for v in sha pkg
    do
        f="${vagrant_downloads}/${!v}"
        if [[ ! -e "${f}" ]]
        then
            echo 1>&2 "Downloading Vagrant '${vagrant_version}' package"
            wget 1>&2 \
                --progress=dot:mega \
                -O "${f}" \
                "${vagrant_url_base}/${vagrant_version}/${!v}"
        fi
    done

    pkg_sha=${pkg}.sha256

    (
        cd ${vagrant_downloads}
        grep "[[:space:]]${pkg}$" "${sha}" > "${pkg_sha}"
        echo 1>&2 "Validating downloaded package"
        sha256sum --check "${pkg_sha}" 1>&2
    ) 1>&2

    case "${distro_family}" in
    (debian)
        vagrant_uninstall=""
        case "${vagrant_version}" in
        (1.7.*|1.8.*)
            vagrant_install=""
            echo "Extracting Vagrant '${vagrant_version}' package under ${vagrant_base}" 1>&2
            dpkg-deb --vextract "${vagrant_downloads}/${pkg}" "${vagrant_base}" 1>&2
            rm -rf "${vagrant_base}/usr"
            #find ${vagrant_pkg_path} -type f -name "*.pc" | xargs sed -i -e 's,^\(prefix=\)\(/opt/.*\)$,\1'${vagrant_base}'\2,' 1>&2
            ;;
        (*)
            vagrant_install="${pkg_install} --allow-downgrades"
            ;;
        esac
        ;;
    (suse)
        vagrant_uninstall="sudo rpm --erase vagrant"
        case "${vagrant_version}" in
        (1.7.*|1.8.*)
            vagrant_install=""
            rpm --initdb --dbpath ${vagrant_base}/rpmdb 1>&2
            rpm --install \
                --dbpath ${vagrant_base}/rpmdb \
                --badreloc --prefix="${vagrant_base}" \
                --nodeps --noscripts --notriggers \
                "${vagrant_downloads}/${pkg}" 1>&2
            rm -rf "${vagrant_base}/usr"
            ;;
        (*)
            vagrant_install="sudo rpm --install"
            ;;
        esac
        ;;
    esac

    # check if we need to uninstall existing vagrant
    if [[ -n "${vagrant_uninstall}" ]]
    then
        if [[ -x /usr/bin/vagrant ]]
        then
            echo 1>&2 Removing existing vagrant package
            ${vagrant_uninstall}
        fi
    fi
    
    # check if need to install the new vagrant package
    if [[ -n "${vagrant_install}" ]]
    then
        echo 1>&2 "Installing Vagrant '${vagrant_version}' package"
        ${vagrant_install} "${vagrant_downloads}/${pkg}" 1>&2
    fi

    mkdir -p "${vagrant_home}"
fi


#
# Ansible bootstrap venv setup
#

# Ansible settings
ansible_version=1.9.6
bootstrap_venvs="${ardana_cache}/venvs"
bootstrap_ansible="${bootstrap_venvs}/ansible-${ansible_version}"

# Create the bootstrap ansible venv if it doesn't exist
if [[ ! -d "${bootstrap_ansible}" ]]
then
    ${venv_cmd} --python python2.7 "${bootstrap_ansible}" 1>&2
    ${bootstrap_ansible}/bin/pip install --upgrade pip wheel 1>&2
fi

# Install specified ansible version in the bootstrap venv if necessary
if [[ ! -x "${bootstrap_ansible}/bin/ansible-playbook" ]];
then
    ${bootstrap_ansible}/bin/pip install "ansible==${ansible_version}" 1>&2
fi


#
# Generate updated environment settings
#

# Check if ansible bootstrap venv already in path, and if not, add it
case :${PATH}: in
(*:${bootstrap_ansible}/bin:*)
    echo "Already using ansible venv '${bootstrap_ansible}'" 1>&2
    ;;
(*)
    echo "Using ansible venv '${bootstrap_ansible}'" 1>&2
    ardana_paths="${bootstrap_ansible}/bin${ardana_paths:+:${ardana_paths}}"
    ;;
esac

# Check for a "local" vagrant install under ${vagrant_base}
if [[ -d ${vagrant_base}/opt/vagrant/bin ]]
then
    # Check if vagrant runtime env already in path, and if not, add it
    case :${PATH}: in
    (*:${vagrant_base}/opt/vagrant/bin:*)
        echo "Already using Vagrant '${vagrant_version}'" 1>&2
        ;;
    (*)
        echo "Using Vagrant '${vagrant_version}'" 1>&2
        ardana_paths="${vagrant_base}/opt/vagrant/bin${ardana_paths:+:${ardana_paths}}"
        ;;
    esac
fi
echo "ARDANA_VAGRANT_VERSION=${vagrant_version};"
echo "export ARDANA_VAGRANT_VERSION;"
echo "VAGRANT_HOME=${vagrant_home};"
echo "export VAGRANT_HOME;"
#echo "LD_LIBRARY_PATH=/usr/lib:/usr.lib64:/usr/lib/x86_64-linux-gnu:/lib:/lib64:/lib/x86_64-linux-gnu:${vagrant_ld_path}:default;"
#echo "export LD_LIBRARY_PATH;"
#echo "PKG_CONFIG_PATH=${vagrant_pkg_path}:default;"
#echo "export PKG_CONFIG_PATH;"

# If we needed to update the path settings
if [[ -n "${ardana_paths}" ]]
then
    echo "PATH=${ardana_paths}:\$PATH;"
    echo "export PATH;"

    # Ensure shell sessions re-evaluate command lists
    case "${SHELL}" in
    (*/bash|*/zsh)
        echo "hash -r;"
        ;;
    esac
fi

# vim:shiftwidth=4:tabstop=4:expandtab
